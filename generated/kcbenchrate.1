.\" Automatically generated by Pandoc 2.9.2.1
.\"
.TH "kcbenchrate" "1" "" "Version 0.9" "User Commands"
.hy
.SH NAME
.PP
kcbenchrate - Linux kernel compile benchmark, rate edition
(EXPERIMENTAL)
.SH SYNOPSIS
.PP
\f[B]kcbenchrate\f[R] [\f[B]options\f[R]]
.SH DESCRIPTION
.PP
Kcbenchrate compiles a Linux kernel on each CPU core in parallel to test
a system\[aq]s performance or stability.
.PP
Note: The optimal number of workers (\[aq]-w\[aq]) that delivers the
best result depends on the machine being benched.
See the section \[dq]ON THE DEFAULT NUMBER OF WORKERS\[dq] below for
details.
.PP
To get comparable results from different machines you need to use the
exact same operating system on all of them.
There are multiple reasons for this recommendation, but one of the main
reasons is: the Linux version this benchmark downloads and compiles
depends on the operating system\[aq]s default compiler.
.PP
If you choose to ignore this recommendation at least make sure to hard
code the Linux version to compile (\[aq]-s 5.4\[aq]), as for example
compiling 5.7 will take longer than 5.4 or 4.19 and thus lead to results
one cannot compare.
Also, make sure the compiler used on the systems you want to compare is
from similar, as for example gcc10 will try harder to optimize the code
than gcc8 or gcc9 and thus take more time for its work.
.PP
Kcbench is accompanied by kcbenchrate.
Both are quite similar, but work slightly different:
.IP \[bu] 2
kcbench tries to build one kernel as fast as possible.
This approach is called \[aq]speed run\[aq] and let\[aq]s make start
multiple compilers jobs in parallel by using \[aq]make -j #\[aq].
That way kcbench will use a lot of CPU cores most of the time, except
during those few phases where the Linux kernel build process is singled
threaded and thus utilizes just one CPU core.
That for example is the case when vmlinux is linked.
.IP \[bu] 2
kcbenchrate tries to keep all CPU cores busy constantly by starting
workers on all of them, which each builds one kernel with just one job
(\[aq]make -j 1\[aq]).
This approach is called \[aq]rate run\[aq].
It takes a lot longer to generate a result than kcbench; it also needs a
lot more storage space, but will utilize the machine and its processors
better.
.SS Options
.TP
\f[B]-b\f[R], \f[B]--bypass\f[R]
After starting a worker wait just a tenths of a second before launching
the next to start all the workers a lot faster than usualy.
This can he useful to create a lot of load quickly, but the benchmark
result might be slightly inaccurate due to caching effects.
.TP
\f[B]-h\f[R], \f[B]--help\f[R]
Show usage.
.TP
\f[B]-i\f[R], \f[B]--iterations\f[R] \f[I]int\f[R]
Determines the number of kernels that each worker will compile before
the end result it printed.
Default: 2
.TP
\f[B]-j\f[R], \f[B]--jobs\f[R] \f[I]int\f[R]
Number of jobs to use when compiling a kernel(\[aq]make -j #\[aq]).
.RS
.PP
The default is \[aq]\f[I]1\f[R]\[aq].
.RE
.TP
\f[B]-m\f[R], \f[B]--modconfig\f[R]
Instead of using a config generated with \[aq]defconfig\[aq] use one
built by \[aq]allmodconfig\[aq] and compile modules as well.
Takes a lot longer to compile, which is more suitable for machines with
a lot of fast CPU cores.
.TP
\f[B]-o\f[R], \f[B]--outputdir\f[R] \f[I]dir\f[R]
Use \f[I]path\f[R] to compile Linux.
Passes \[aq]O=\f[I]dir\f[R]/kcbench-worker/\[aq] to make when calling it
to compile a kernel; use a temporary directory if not given.
.TP
\f[B]-s\f[R], \f[B]--src\f[R] \f[I]path\f[R]|\f[I]version\f[R]
Look for sources in \f[I]path\f[R],
\[ti]/.cache/kcbench/linux-\f[I]version\f[R] or
/usr/share/kcbench/linux-\f[I]version\f[R].
If not found try to download \f[I]version\f[R] automatically unless
\[aq]--no-download\[aq] was specified.
.TP
\f[B]-v\f[R], \f[B]--verbose\f[R]
Increase verboselevel; option can be given multiple times.
.TP
\f[B]-w\f[R], \f[B]--workers\f[R] \f[I]int\f[R]
Number of workers to use.
Default: Number of CPUs.
The optimal setting will depend on the particual machine.
See ON THE DEFAULT NUMBER OF WORKERS for details.
.TP
\f[B]-V\f[R], \f[B]--version\f[R]
Output program version.
.TP
\f[B]--cc \f[BI]exec\f[B]\f[R]
Use \f[I]exec\f[R] as target compiler.
.TP
\f[B]--cross-compile \f[BI]arch\f[B]\f[R]
EXPERIMENTAL: Cross compile the Linux kernel.
Cross compilers for this task are packaged in some Linux distribution.
There are also pre-compiled compilers available on the internet, for
example here: https://mirrors.edge.kernel.org/pub/tools/crosstool/
.RS
.PP
Values of \f[I]arch\f[R] that kcbench/kcbenchrate understand: arm arm64
aarch64 riscv riscv64 powerpc powerpc64 x86_64
.PP
Building for archs not directly supported by kcbench/kcbenchrate should
work, too: just export ARCH= and CROSS_COMPILE= just like you would when
normally cross compiling a Linux kernel.
Do not use \[aq]--cross-compile\[aq] in that case and keep in mind that
kcbench/kcbenchrate configure the compiled Linux kernel with the make
target \[aq]defconfig\[aq] (or \[aq]allmodconfig\[aq], if you specify
\[aq]-m\[aq]), which might be unusual for the arch in question, but
might be good enough for benchmarking purposes.
.PP
Be aware there is a bigger risk running into compile errors (see below)
when cross compiling.
.RE
.TP
\f[B]--crosscomp-scheme \f[BI]scheme\f[B]\f[R]
On Linux distributions that are known to ship cross compilers kcbench/
kcbenchrate will assume you want to use those.
This parameter allows to specify one of the various different naming
schemes in cases this automatic detection fails or work you want
kcbench/kcbenchrate to find them using a \[aq]generic\[aq] scheme that
should work with compilers from various sources, which is the default on
unknown distributions.
.RS
.PP
Valid values of \f[I]scheme\f[R]: debian fedora generic redhat ubuntu
.RE
.TP
\f[B]--hostcc \f[BI]exec\f[B]\f[R]
Use \f[I]exec\f[R] as host compiler.
.TP
\f[B]--infinite\f[R]
Run endlessly to create system load.
.TP
\f[B]--llvm\f[R]
Set LLVM=1 to use clang as compiler and LLVM utilities as GNU binutils
substitute.
.TP
\f[B]--add-make-args \f[BI]string\f[B]\f[R]
Pass additional flags found in \f[I]string\f[R] to \f[C]make\f[R] when
creating the config or building the kernel.
This option is meant for experts that want to try unusual things, like
specifying a special linker
(\f[C]--add-make-args \[aq]LD=ld.lld\[aq]\f[R]).
.RS
.PP
Use with caution!
.RE
.TP
\f[B]--no-download\f[R]
Never download Linux kernel sources from the web automatically.
.TP
\f[B]--savefailedlogs \f[BI]path\f[B]\f[R]
Save log of failed compile runs to \f[I]path\f[R].
.SH ON THE DEFAULT NUMBER OF WORKERS
.PP
The optimal number of workers (-w) in most cases will be identical to
the number of CPU cores in the tested machine, that\[aq]s why this is
the default.
But some systems might be a bit faster if they are oversubscribed a
little.
Others might be quicker if you only utilize the real CPU cores and let
the cores idle which are only available due to SMT (Simultaneous
Multi-Threading, also called Hyper-threading/HT by Intel).
.PP
For details and some results that show unexpected effects see the
kcbench man page in the section \[aq]ON THE DEFAULT NUMBER OF JOBS\[aq].
.PP
Ideally kcbenchrate would do what kcbench does and try a few settings to
narrow down the optimal setting.
As this would take quite a while this exercise is left to the user.
Impatient users should consider finding the optimal number of jobs with
kcbench and then try to start kernbenchrate with as many workers, as it
might be a good setting for it as well.
You can also try to experiment with the number of jobs used per worker
(-j), maybe some machines perform best if you start worker on every
second core, but use 2 jobs per worker.
.SH ON FAILED RUNS DUE TO COMPILATION ERRORS
.PP
The compilation is unlikely to fail, as long as you are using a settled
GCC version to natively compile the source of a current Linux kernel for
popular architectures like ARM, ARM64/Aarch64, or x86_64.
For other cases there is a bigger risk that compilation will fail due to
factors outside of what kcbench/kcbenchrate control.
They nevertheless try to catch a few common problems and warn, but they
can not catch them all, as there are to many factors involved:
.IP \[bu] 2
Brand new compiler generations are sometimes stricter than their
predecessors and thus might fail to compile even the latest Linux kernel
version.
You might need to use a pre-release version of the next Linux kernel
release to make it work or simply need to wait until the compiler or
kernel developers solve the problem.
.IP \[bu] 2
Distributions enable different compiler features that might have an
impact on the kernel compilation.
For example gcc9 was capable of compiling Linux 4.19 on many
distributions, but started to fail on Ubuntu 19.10 due to a feature that
got enabled in its GCC.
Try compiling a newer Linux kernel version in this case.
.IP \[bu] 2
Cross compilation increases the risk of running into compile problems in
general, as there are many compilers and architectures our there.
That for example is why compiling the Linux kernel for an unpopular
architecture is more likely to fail due to bugs in the compiler or the
Linux kernel sources that nobody had noticed before when the compiler or
kernel was released.
This is even more likely to happen if you start kcbench/kcbenchrate with
\[aq]-m/--allmodconfig\[aq] to build a more complex kernel.
.SH HINTS
.PP
Running benchmarks is very tricky.
Here are a few of the aspects you should keep mind when doing so:
.IP \[bu] 2
Do not compare results from two different archs (like ARM64 and x86_64);
kcbench/kcbenchrate compile different code in that case, as they will
compile a native kernel on each of those archs.
This can be avoided by cross compiling for a third arch that is not
related to any of the archs compared (say RISC-V when comparing ARM64
and x86_64).
.IP \[bu] 2
Unless you want to bench compilers do not compare results from different
compiler generations, as they will apply different optimizations
techniques.
For example to not compare results from GCC7 and GCC9, as the later
optimizes harder and thus will take more time generating the code.
That\[aq]s also why the Linux version compiled by default depends on the
machine\[aq]s compiler: you sometimes can\[aq]t compile older kernels
with the latest compilers anyway, as new compiler generations often
uncover bugs in the Linux kernel source that need get fixed for
compiling to succeed.
For example, when GCC10 was close to release it was incapable of compile
the then latest Linux version 5.5 in an allmodconfig configuration due
to a bug in the Linux kernel sources.
.IP \[bu] 2
Compiling a Linux kernel scales very well and thus can utilize
processors quite well.
But be aware that some parts of the Linux compile process will only use
one thread (and thus one CPU core), for example when linking vmlinuz;
the other cores will idle meanwhile.
The effect on the result will grow with the number of CPU cores.
.PP
If you want to work against that consider using \[aq]-m\[aq] to build an
allmodconfig configuration with modules; comping a newer, more complex
Linux kernel version can also help.
But the best way to avoid this effect is by running kcbenchrate.
.IP \[bu] 2
kcbench/kcbenchrate by default set CCACHE_DISABLE=1 when calling
\[aq]make\[aq] to avoid interference from ccache.
.SH EXAMPLES
.TP
To let kcbenchrate decide everything automatically simply run:
$ kcbenchrate
.SH RESULTS
.PP
By default the line you are looking for is this:
.PP
4 workers completed 8 kernels so far (avrg: 1100.75 s/run) with a rate
of 13.08 kernels/hour.
.PP
On this quad-core processor four workers each compiled two kernels.
On average, it took each worker 1100.77 seconds to compile one kernel
image.
With a speed like this the machine can compile 13.08 kernels per hour
(3600/1100.75*4).
.SH MISSING FEATURES
.IP \[bu] 2
kcbenchrate lacks something similar to \[aq]kcbench
--detailedresults\[aq]
.IP \[bu] 2
kcbenchrate takes the results verbatim and does not validate them for
saneness.
Thus, if for example there is some hiccup in the system that heavily
slows down one worker temporary kcbenchrate will neither notice nor tell
you.
.SH SEE ALSO
.PP
\f[B]kcbench(1)\f[R], \f[B]time(1)\f[R]
.SH AUTHOR
.PP
Thorsten Leemhuis <linux [AT] leemhuis [DOT] info>
